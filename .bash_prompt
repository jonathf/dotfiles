#!/usr/bin/env bash

__prompt()
{
    _git_info()
    {
        git rev-parse --inside-work-tree >/dev/null 2>&1 || return

        local branch_name="$(git symbolic-ref --short HEAD)"
        [ -n "$branch_name" ] && branch_name="${branch_name#refs/heads/}"  # strip prefix
        [ -z "$branch_name" ] && branch_name="$(git rev-parse --short -q HEAD)"  # use short-hash if detached
        [ -n "$(git status --porcelain | grep -v '^??')" ] && branch_name="$branch_name*"  # note untracked
        [ -n "$branch_name" ] && echo -ne "\e[0;90m$branch_name "

        local ref_branch="$(git symbolic-ref -q HEAD 2> /dev/null)"
        local remote_branch="$(git for-each-ref --format='%(upstream:short)' $ref_branch)"

        [ -z "$remote_branch" ] && return # no upstream
        [ "$(git branch -a | grep "$remote_branch" | wc -l)" = "0" ] && return # upstream deleted

        local forwards="$(git rev-list --count $remote_branch..$1 2> /dev/null)"
        [ "$forwards" != "0" ] && echo -ne "\e[0;36m+$forwards"

        local backwards="$(git rev-list --count $1..$remote_branch 2> /dev/null)"
        [ "$backwards" != "0" ] && echo -ne "\e[0;36m-$backwards"
    }

    _ps1() {
        job_count="$(jobs -r | wc -l | xargs)"
        [ "$job_count" != "0" ] && echo -ne "\e[0;33m"$(eval "printf '&%.0s' {1..$job_count}")

        sleep_count="$(jobs -s | wc -l | sed -e 's/ //g')"
        [ "$sleep_count" != "0" ] && echo -ne "\e[0;33m"$(eval "printf 'z%.0s' {1..$sleep_count}")

        [ -n "$SSH_TTY" ] && echo -ne "\e[0;34m\h:"  # on remote
        echo -ne "\e[0;93m\w "  # user name
        _git_info
        echo -e ""  # newline
        [ -n "$VIRTUAL_ENV" ] && echo -ne "\e[0;90m$(basename $VIRTUAL_ENV) "
        echo -ne "\e[0;92m\\$ "
    }

    ps1() {
        local end="\[$( { tput sgr0 || tput me ; } 2>/dev/null )\]"
        PS1="$(_ps1)$end\e[m"
    }
    PROMPT_COMMAND="ps1${PROMPT_COMMAND:+;$PROMPT_COMMAND}"
}

__prompt
unset __prompt
